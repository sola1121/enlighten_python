1. 字符类型的宽度和数值类型的宽度的区别
    1) 数值类型的宽度仅仅为显示宽度, 只用于select查询显示,和占用的存储空间大小无关,可用zerofill查看效果
    2) 字符类型的宽度超过则无法存储
说明:
    zerofill是在创建表的时候让相应字段使用0填充到数值的长度, 仅仅是填充, 不会对值有影响

2. where条件子句(配合查询, 修改, 删除操作)
    1) 语法格式
        select * from 表名 where 条件;
        注意: where子句只能操作表中实在存在的字段, 而having可以

3. 表记录管理
    1) 删除表记录
        delete from 表名 where 条件;   -- 不指定条件, 默认删掉表中所有的数据
    2) 更新表记录
        update 表名 set 字段名1=值1, 字段名2=值2, .. where 条件;   -- 不指定条件, 会将表中的所有数据更改
    3) 在表中插入记录 
        insert into 表名 values(值集合1), (值集合2), (值集合3), ...;   -- 每一个值代表一行的所有信息
        insert into 表名(字段名1, 字段名2, ...) values(值1, 值2, ...);   -- 相对应字段插入相应值
    4) 查询表记录
        select * from 表名 [where 条件];
        select 字段名1, 字段名2, ... from 表名 [where 条件];

4. 运算符操作
    1) 数值比较&字符比较
        数值比较运算符: =, !=, >, >=, <, <=
        字符比较运算符: =, !=

    2) 逻辑比较
        运算符
            and (两个或者多个条件同时满足)
            or (两个或者多个条件有一个满足就可以)

    3) 范围内比较
        (1) 运算符
            between and, in, not in
        (2) 语法格式
            between 值1 and 值2
            in(值1, 值2, ...)

5. 匹配空, 非空
    1) 空: is null
    2)非空: is not null
    注意
        null: 空值, 必须用is或者is not去匹配
        ""  : 空字符串, 用=或者!=去匹配

6. 模糊比较
    1) where 字段名 like 表达式;
    2) 通配符
        _ : 匹配单个字符
        % : 匹配0到多个字符

7. 正则匹配查询 regexp
    1) where 字段名 regexp "正则表达式"
    2) 正则表达式符号
        ^ : 以...开头
        $ : 以...结尾
        . : 在Mysql 8.0 中匹配任意一个字符, 以下版本匹配的是字节
        []: 包含...内容
        * : 匹配前面的字符出现0次或者多次

8. SQL查询
    1) 总结(执行顺序)
        select ... ❸聚合函数 from 表名;
        ❶where ...
        ❷group by ...
        ❹having ...
        ❺order by ...
        ❻limit ...
    
    2) order by
        作用: 给查询的结果进行排序
        语法格式: order by 字段名 排序方式;
        排序方式: 
            asc(默认): 升序, 小到大
            desc : 降序, 大到小

    3) limit(永远放在SQL语句的最后)
        作用: 限制显示查询记录的个数
        用法
            limit n   --> 显示n条记录
            limit m, n   --> 从第(m+1)条开始, 显示n条记录
    
    4) group by
        作用: 给查询的结果进行分组
        工作方式: 先分组在去重, 分组外的字段名不能出现在select查询中
        注意:
            group by之后的字段名必须要为select之后的字段名
            如果select之后的字段没有在group by语句之后, 则必须要对该字段进行聚合处理
        示例:
            select country, avg(gongji) from sanguo group by country;
            执行流程:
                先分组(此时未去重) group by country
                在聚合(求每组的平均攻击值)
                去重
    5) having
        作用: 对查询的结果进行进一步筛选, 可以对使用聚合函数生成的字段进行筛选
        注意:
            having语句通常与group by语句联合使用, 用来过滤由group by语句返回的记录集
            having语句的存在弥补了where条件子句不能与聚合函数联合使用的不足, where操作的是表中实际存在的字段, having操作的是聚合函数生成的显示列

9. 聚合函数
    1) 分类
        (1) avg(字段名) : 求字段的平均值
        (2) sum(字段名) : 求和
        (3) max(字段名) : 求最大值
        (4) min(字段名) : 求最小值
        (5) count(字段名) : 统计该字段记录的个数, 会忽略null

10. distinct
    作用: 不显示字段的重复值
    注意:
        distinct处理的是distinct和from之间的所有字段,所有字段值必须完全相同才可以去重
        distinct不能对任何字段做聚合处理

11. 查询表记录是可以做数学运算
    1) 运算符
        +   -   *   /   %

12. 约束
    1) 作用
        为了保证数据的完整性, 一致性, 有效性, 可以限制无效的数据插入到数据表中
    2) 约束分类
        (1) 默认约束 default
            作用:
                在插入记录时, 如果不给该字段赋值, 则使用默认值
            格式:
                字段名 数据类型 default 默认值,
        (2) 非空约束
            作用:
                不允许该字段的值有空值null记录
            格式:
                字段名 数据类型 not null,

13. 索引
    定义:
        对数据库中表的一列或者多列的值进行排序的一种结构(MySQL中索引引用BTree方式)
    索引的优点
        可以加快数据的检索速度
    索引的缺点
        当对表中的数据进行增加, 修改, 删除的时候, 索引需要动态维护, 降低了数据的维护速度
        索引需要占用物理存储空间 (数据库(基于innodb引擎)目录中 /var/lib/mysql)
    索引示例:
        -->运行 insert_.py 文件, 其插入1000000条数据
        -->开启性能分析
            show variable like "profiling%"   -- 性能分析参数profiling, %是通配符
            set profiling=1   -- 如果没有开启, 开启性能分析
            现在以后每执行一次SQL将会记录其执行时间, 通过 show profiles; 可以查看
        -->create index 索引名 on 表名(字段名);   -- 创建某表具体字段的索引
