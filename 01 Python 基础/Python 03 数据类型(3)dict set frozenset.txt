字典 dict
  字典是一种可变的容器,可以存储任意类型的数据
  字典中的每个数据都是用"键"(key)进行索引,而不像序列(字符串,列表,元组)可以用下标来进行索引
  字典中的数据没有先后关系,字典的存储是无序的
  字典中的数据以键-值(key-value)对的形式进行存储
  字典的键不能重复,且只能用不可变类型作为字典的键

字典的字面值表示方法:
  以{}括起来, 以冒号(:)分隔键-值对,各键值对之间用逗号(,)分隔开

创建空字典
    d = {}
创建非空的字典字面值
    d = {"ai": "huaQ", 1: 3.14, (2 ,3 ,4): "key is a tuple"}
    d = {123: [1 ,2 ,3]}
    d = {True: "str True", None: "None is nothing"}
    d = {1: {"ai": "kizuna"}, 2: {"siro": "iruka"}, }
字典的值(value)可以为任意类型, 键必须是不可变类型且不重复

字典的构造(创建)函数 dict
dict() 生成一个空的字典, 等同于{}
dict(iterable) 用可迭代对象初始化一个字典
dict(**kwargs) 用命名关键字传参形式生成一个字典
示例:
    d = dict()   # 空字典
    d = dict([("name", "siro"), ("ai", "kizuna")])
    d = dict(name="siro", age=1)

可变类型不可以作为字典的键 共四个
    列表 list,  字典 dict,  集合 set,  字节数组 bytearray

字典的键索引
  用[]运算符可以获取字典内"键"所对应的值
键索引的语法
  字典[键]
示例:
    d = {"name": "siro", "age": 1}
    d["age"]

添加/修改字典的元素
  d = {}
  d["name"] = "siro"   # 创建新的键值对
  d["age"] = 15   # 创建新的键值对
  d["age"] = 1   # 修改'age'这个键所对应的值

del语句 用来删除字典的键(同时释放与值的引用关系)
    d = {"name": "siro", "age": 1}
    del d["name"]
    del d["age"]

字典的成员资格判断运算符 in / not in
  可以用in运算符来判断一个键是否存在于字典中,如果存在返回True否则返回False
  not in 与 in 的返回值相反
示例:
    d = {"name": "siro", "age": 1}
    "name" in d   # True
    1 in d   # False   只以键为判断标准, 不以值为判断标准

列表的in运算符计算时间会因列表中的元素个数增加而增加
字典的in运算符计算时间不会因为键值对的个数增加而增加,操作速度快于列表
这是因为字典的存储使用了散列表, 这也是为什么字典无序且键不能变的原因

字典的迭代访问
  字典是可迭代对象,字典只能对键进行迭代访问
    d = {1: "one", 2: "two", 3: "three"}
    for x in d:
        print("key:", x, "value:", d[x])

可用于字典的内建(built-in)函数
    len(x) 返回字典的键值对个数
    max(x) 返回字典键的最大值
    min(x) 返回字典键的最小值
    sum(x) 返回所有键的和
    any(x) 对键进行真值测试, 任何满足返回真
    all(x) 对键进行真值测试, 全部满足返回真

字典方法:
>>> help(dict)

字典推导式 dict comprehension
  字典推导式是用可迭代对象依次生成字典的方式
语法:
  {键表达式: 值表达式 for 变量 in 可迭代对象 [if 真值表达式式]}
  注:[]的内容可省略
示例:
  生成一个字典,键为数字(10以内), 值为键的平方
  d = {x:x**2 for x in range(10)}

字典推导式的嵌套
  语法同列表推导式:
    {x+y: x+"_"+y for x in "ABC" for y in "123"}

字典 VS 列表
  1) 都是可变对象
  2) 索引方式不同, 列表用于整数索引, 字典用于键索引
  3) 字典的查找速度可能会快于列表(重要)
  4) 列表的存储是有序的, 字典的存储是无序的

===============================================================================

集合 set
  集合是可变的容器
  集合内的数据对象都是唯一的(不能有重复)
  集合是无序的存储结构,集合中的数据没有先后关系
  集合内的元素必须是不可变对象
  集合是可迭代的(可以用for等遍历)
  集合是相当于只有键没有值的字典(键则是集合的数据)

创建空集合
    set()
创建非空集合
  集合的字面值表示方式 用{}括起来
  内部都为不可变对象,各对象之间用(,)分隔
    s = {1, 2, 3}
    s = {"A", "B", "C"}
    s = {1, "two", 3, "four"}
    # s = {1, 2, [3, 4]}   # 列表是可变序列,不能作为集合的值
    s = {1, 2, 2, 3, 3, 4}   # s = {1 ,2, 3, 4}元素不重复

集合的构造(创建)函数 set
  set() 创建一个空的集合对象(不能用{}来创建空集合)
  set(iterable) 用可迭代对象创建一个集合
示例:
    s = set("siro")   # s = {'s', 'i', 'r', 'o'}
    s = set(range(10))

集合的运算
  交集, 并集, 补集, 子集, 超集
运算符:
    &   |   -   ^   >   >=   <   <=   ==   !=

& 生成两个集合的交集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s1 & s2   # {2, 3}

| 生成两个集合的并集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s1 | s2   # {1, 2, 3, 4}

- 生成两个集合的补集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s1 - s2   # {1} 生成属于s1但不属于s2的所有元素集合
    s2 - s1   # {4}

^ 生成两个集合的对称补集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s3 = s1 ^ s2   # {1, 4}
    s3 = (s1 - s2) | (s2 - s1)

> 判断一个集合是另一个集合的超集
< 判断一个集合是另一个集合的子集
s1 = {1, 2, 3}
s2 = {2, 3}
s1 > s2   # True, s1为s2的超集
s2 < s1   # True, s2为s1的子集

==   !=
s1 = {1, 2, 3}
s2 = {3, 2, 1}
s1 == s2   # True
s1 != s2   # False

in / not in 运算符
  等同于字典等的in与not in运算符, 当某个值存在于集合中, 返回True, 否则返回False

字典和集合的优点
  in / not in 运算速度快于列表和元素
  
能用于集合的内建函数
    len(), max(), min(), sum(), any(), all()

集合中常用的方法:
详见
>>> help(set)

集合中的元素不能指定修改,只能删掉后重添加

集合是可迭代对象

集合推导式
语法:
  {表达式 for 变量 in 可迭代对象 [if 真值表达式]}
  注: []中的内容可以省略

===============================================================================

固定集合 frozenset
  是不可变的, 无序的, 含有唯一元素的集合(容器)
作用:
  固定集合可以作为字典的键, 还可以作为集合的值

创建空的固定集合
  frozenset()
创建非空的固定集合
  frozenset(iterable)
示例:
  frozenset(range(5))

运算符:
  固定集合的运算符同 集合set 完全一致
  &交集   |并集   -集合相减   ^补集   <   <=   >   >=   ==   !=

固定集合的方法
  相当于集合的全部方法去掉修改集合的方法

