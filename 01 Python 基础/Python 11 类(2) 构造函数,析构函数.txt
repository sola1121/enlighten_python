Python中, 有一些被称为魔法方法的特殊方法, 其以双下划线开头和结束.
特殊情况下会被自动调用, 不需要开发者手动调用.

以下__new__, __init__, __del__都是这样的方法.
对这些方法进行重写, 可以在创建实例对象或这销毁实例对象的时候完成一些特殊的要求


---------------------------------------

初始化方法
作用:
    创建对象初始化实例变量(属性)
格式:
class 类名(继承列表):
    def __init__(self[, 参数列表]):
        语句块

注: []代表其中的内容可以没有
    对象创建后也可以手动使用__init__方法,在进行一次初始化

说明:
    1) 初始化方法名必须为__init__,不可改变
    2) 在一个类中只能有一个__init__方法
    3) 初始化方法会在实例创建后自动调用,且将实例自身通过第一个参数self传入__init__方法
    4) 初始化方法内如果需要使用return返回, 则必须返回None

示例:
class Car:
    """车类
    """
    def __init__(self, color, brand, model):
        self.color = color
        self.brand = brand
        self.model = model
        print("__init__方法被调用.")
    
    def run(self, speed):
        print("The %s %s %s is running in speed %dkm/h on the high way."
              %(self.color, self.brand, self.model, speed))

car1 = Car("white", "audio", "A4")
print(car1.brand, car1.model)
car1.run(120)


---------------------------------------

析构函数

__del__(self): 定义了一个对象被销毁（即其引用计数降到零）时的行为。

调用时机
    1) 当一个对象的引用计数降到零时，__del__ 方法会被自动调用。
    2) 在 Python 程序结束时，所有的对象都会被销毁，此时也会调用 __del__ 方法（除非程序非正常退出）。
    3) 主动调用del关键字清除对象

这个方法通常被称为析构器，尽管在 Python 中它的行为与传统的析构器有所不同。

注意事项
    1) __del__ 方法的调用并不保证立即发生，因为 Python 的垃圾收集器是按需运行的，且其行为可能因不同实现（如 CPython、PyPy）而异。
    2) 在 __del__ 方法中，应避免进行复杂的操作，因为此时对象的生存期即将结束，某些资源可能已经不可用。
    3) __del__ 方法不能保证总是被调用。例如，如果程序非正常退出（如发生未处理的异常），__del__ 可能不会被调用。
    如果对象参与了循环引用，__del__ 方法可能不会被立即调用，直到垃圾收集器检测并处理这些循环引用。

使用场景
    1) 释放外部资源，如关闭文件、网络连接或数据库连接。
    2) 执行一些清理工作，例如删除临时文件或目录。


---------------------------------------

__new__(cls, [...]): 在实例化一个类之前调用，用于创建类实例, 其返回一个实例，通常是 cls 的实例.

使用场景
    当想要控制对象的创建过程时，比如实现单例模式。
    当继承不可变类型（如 str、int、tuple）并希望在实例化时进行自定义操作时。
    当想要实现工厂模式，根据不同的参数创建不同类的实例时。


实现单例模式的例子：
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance

# 测试单例
a = Singleton()
b = Singleton()
print(a is b)  # 输出 True，说明 a 和 b 是同一个实例

以上__new__ 方法首先检查 _instance 属性是否已经被设置。
如果没有，它将调用超类的 __new__ 方法来创建一个新实例，并将其赋值给 _instance。
在随后的调用中，它将直接返回这个已创建的实例，从而确保类的实例是唯一的。

注意事项
   1) __new__ 方法在 __init__ 方法之前被调用，并且负责返回实例，而 __init__ 方法负责初始化这个实例。
   2) 在自定义 __new__ 方法时，通常需要调用 super().__new__(cls, [...]) 来确保实例的创建过程能够正常进行。
   3) 如果 __new__ 方法返回了一个不是 cls 的实例，那么 __init__ 方法不会被调用。
