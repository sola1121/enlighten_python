
----------------函数递归-------------------

递归函数 recursion
  函数直接或间接的调用自身
递归说明:
  递归一定要控制递归的层数,当符合某一条件时要终止递归调用,即递归一定要有递归出口
  几乎所有的递归都能用while循环替代
  函数每次调用的时候都在内存开辟新的空间以临时保存产生的变量等,调用完毕返回调用它的内存块,及所在语句块
  Python递归深度最大为1000, 可使用sys.getrecursionlimit()查看, sys.setrecursionlimit(整型值)修改

示例1:
    def func():
        func()   # 直接调用自身
    func()
    print("func调用已返回.")

示例2:
    def fa():
        fb()
    def fb():
        fa()
    fa()
    print("不可能完成递归, 此句不会打印.")

示例3:
    # 打印1 2 3 4 5
    def fn(n):
        print(n)
        if n == 5:
            return
        fn(n + 1)   # 递归调用至下一层

示例4:
    # 用递归求n的阶乘
    def factorial(n):
        if n == 1:
            return 1
        return n * factorial(n-1)

走楼梯似得调用方式
就像走地下室,每一次递归就是向下走一层,但走到最底层(1000或所定义的),就往回走,会接着调用上层

其实现逻辑是由函数调用栈完成的, 函数调用时压栈, 完成调用出栈

递归的优缺点
  优点:
    递归可以把问题简单化,让思路更为清晰,代码更简洁
  缺点:
    递归因系统环境影响大,因为使用函数调用栈,每一层函数都会造成资源消耗,当递归深度太大时,可能会得到不可预测的结果


-----------------函数回调------------------

回调 Callback
    回调是一种在编程中常用的设计模式
    其允许将一个函数作为参数传递给另一个函数，以便在将来某个时刻被调用。
    被传递的函数称为回调函数, 调用他的函数称为主函数或主调函数, 函数可以在执行过程中的某个特定点调用回调函数。
    
    在事件驱动、异步编程和库/框架设计中。

使用场景
    1) 异步操作：在执行异步任务（如网络请求、文件I/O操作）时，你通常会提供一个回调函数，以便在任务完成时执行。
    2) 事件处理：在图形用户界面（GUI）编程中，当用户与界面交互（如点击按钮、移动鼠标）时，系统会调用相应的回调函数来处理事件。
    3) 插件系统：在插件或扩展系统中，主程序可以定义接口，插件开发者通过实现这些接口来提供回调，从而扩展主程序的功能。

优点：
    灵活性：回调可以提供更大的灵活性，允许调用者自定义被调用函数的行为。
    解耦和：通过回调，可以减少模块间的直接依赖，使得代码更易于维护和扩展。
缺点：
    可读性：如果过度使用或不当使用回调，可能会导致代码难以理解和维护，尤其是当回调嵌套或链式调用时。
    控制流：回调可能会打乱正常的程序流程，使得控制流变得不那么直观。

注意事项
    确保回调函数的签名（参数和返回类型）与调用它的函数期望的一致。
    避免回调地狱（callback hell），即回调函数中嵌套多层回调，这会使代码难以理解和维护。


示例, 异步编程中
import asyncio

async def main():
    print("主函数开始执行")
    await asyncio.sleep(1)
    print("主函数执行完毕")

def callback():
    print("回调函数被调用")

# 创建事件循环
loop = asyncio.get_event_loop()
# 安排主函数执行
task = loop.create_task(main())
# 在任务完成后调用回调
task.add_done_callback(callback)
# 运行事件循环直到任务完成
loop.run_until_complete(task)
