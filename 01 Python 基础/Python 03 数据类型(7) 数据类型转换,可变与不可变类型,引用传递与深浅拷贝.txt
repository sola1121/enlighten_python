Python中的7大数据类型
    数值类型
    布尔类型
    字符串
    元组
    列表
    字典
    集合


数据类型转换
    将一种类型转换为另一种类型

常见的类型转换方法
    int(x) : 将x转换为一个整数
    float(x) : 将x转换为一个浮点数
    bool(x) : 将x转换为一个布尔类型值
    complex(real [,imag]) : 创建一个复数, real为实部, imag为虚部
    str(x) : 将对象x转换为字符串
    repr(x) : 将对象x转换为表达式字符串
    eval(str) : 用来计算在字符串中的有效Python表达式, 并返回计算值
    tuple(s) : 将序列s转换为一个元组
    list(s) : 将序列s转换为一个列表
    chr(x) : 将一个整数转换为一个Unicode字符
    ord(x) : 将一个字符转换为他的ASCII整数值
    hex(x) : 将一个整数转换为十六进制字符串
    oct(x) : 将一个整数转换为八进制字符串
    bin(x) : 将一个整数转换为一个二进制字符串


当把浮点类型的值转换为整型, 将会舍弃小数点后的精度.

除0以外的整数, 转换为bool类型的数据, 将会为True, 0值为False

eval()函数主要针对字符串类型的数据, 将字符串中的数据转换为原数据类型
如
    num = eval(input("输入内容: ))   # 如果输入整数, 将会转换为整型, 如果输入浮点数, 将会转换为浮点类型
    num = eval(x + y)   # 将会向num返回表达式x+y的计算的值
eval()函数还可以转换表达式
如
    sum = eval("1+1")   # 会得到2
当使用字符串转换为字符串的时候, 将会报错
如
    s = eval("abc")   # 将字符串转换为对应的原数据类型, 还是字符串, 会报错


---------------------------------------------------------------

可变数据对象
    内存空间中的数据可以被修改的数据类型, 即能做到不修改引用地址的前提下修改数据的值
    list
    dict
    set
    bytearray

不可变数据对象
    内存空间中的数据不可以被修改的数据类型, 即不能做到不修改应用地址的前提下修改数据的值
    int
    float
    complex
    bool
    str
    tuple
    bytes

引用
    引用就是变量和数据之间的关联关系, 类似C中的指针
引用地址
    Python中的引用地址, 是根据内存地址计算出来的唯一标识, 可以认为引用地址就是内存地址, 引用地址相同数据一定相同
    使用is运算符, 可以判断数据的引用地址是否相同, 使用id()函数可以查看变量的引用地址

Python中的赋值操作都是引用赋值
如
# 将字面量int(10)赋值给a, 再将a赋值给b
a = 10
b = a
以上三个id(10)==id(a)==id(b), 即地址相同, 引用同一块内存

在函数参数传递中, 传递的也是数据的引用地址值
若在函数中当对引用地址上的数据做了更改, 原先的数据也会改变, 类似C中的以指针作为函数参数, 传递的是变量的地址值
这里要区分用==或is运算符来判断是否数据相同, 前者是判断每个值是否相同, 后者是判断引用的地址是否相同

可变类型对象, 数据值相同, 类型也相同, 不一定引用地址相同, 也就不是同一个数据
不可变类型对象, 如字符串, 元组, 数, 数值相同, 类型也相同, 引用地址就相同, 也就是同一个数据

每次修改可变数据类型对象, 都是在原地址上修改内容
不可对不可修改数据类型对象所在的内存地址上的数据进行修改, 如有元组t=(100,), 不可以t[0]=101
但是可以更改变量指向的内存地址, 如t=(101,), 这样会指向一个新的元组

Python对内存的封装很好, 变量内存不外露, 做了封装


---------------------------------------------------------------

浅拷贝
    浅拷贝是指复制一个对象，但是不复制该对象内部的子对象。在浅拷贝中，原始对象的引用会被复制到新对象中，但是子对象本身不会被复制。

    类似于C语言中, 指针间相互赋值, 仅将变量所在的地址值复制并赋值给新的变量, 新的变量与原先变量都指向同一内存块.

实现浅拷贝
    1) 使用标准库中的 copy 模块里的 copy() 函数。
    2) 使用对象的 copy() 方法（如果对象支持的话, 如dict中的copy方法）。
    3) 使用切片操作对列表进行浅拷贝。

对于可变类型对象的浅拷贝
    可变对象意味着创建一个新的容器，但是容器内的元素是对原始元素的一个引用。
    因此，修改原始对象中的可变元素时，所有通过浅拷贝创建的副本也会受到影响。
对于不可变类型对象的浅拷贝
    由于不可变对象的值不能在原地修改，所以浅拷贝和深拷贝在这种情况下几乎没有区别。
    这意味着其会以创建一个新的容器，容器内的元素仍然是指向原始元素的引用。
    因此当修改了原始对象（如果它内部包含可变对象的话），也不会影响到它的浅拷贝副本，因为不可变对象的任何修改都会导致创建一个新的对象.

示例
import copy

# 列表的浅拷贝
lst1 = [1, 2, [3, 4]]
lst2 = copy.copy(lst1)
lst3 = lst1[:]
lst4 = list(lst1)  # 使用构造函数也是一种浅拷贝

lst1[2][0] = 999
print(lst1)  # [1, 2, [999, 4]]
print(lst2)  # [1, 2, [999, 4]]，因为子列表是引用
print(lst3)  # [1, 2, [999, 4]]
print(lst4)  # [1, 2, [999, 4]]


深拷贝
    深拷贝是指复制一个对象及其所有子对象。在深拷贝中，原始对象及其内部的所有子对象都会被复制，产生一个完全独立的副本。

    类似于C语言中, 开辟一块新内存, 将值复制到新的地址, 并指向新的变量. 新变量与原先变量指向不一样的内存块, 但数据内容是一样的.

实现深拷贝：
    1) 使用标准库中的 copy 模块里的 deepcopy() 函数。

对于可变类型对象的深拷贝
    其会开辟新的内存块创建一个新的对象，然后递归地将在原始对象中找到的对象的副本放置到新对象中。
    这意味着不仅仅是顶层对象被复制，而是原始对象中的所有子对象也被复制。
对于不可变类型对象的深拷贝
    由于不可变对象一旦创建就不能更改, 因此实际上并不需要深拷贝来创建一个不可变对象的独立副本。
    在Python解释器中是将不可变类型对象的引用赋值给新的拷贝对象, 该对象内的元素仍然是指向原始元素。 

示例
import copy

# 列表的深拷贝
lst1 = [1, 2, [3, 4]]
lst5 = copy.deepcopy(lst1)

lst1[2][0] = 999
print(lst1)  # [1, 2, [999, 4]]
print(lst5)  # [1, 2, [3, 4]]，因为深拷贝创建了子列表的副本
