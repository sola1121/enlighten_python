同步和互斥

目的: 对共有资源的操作会产生争夺, 同步和互斥是一种解决争夺的方案

临界资源: 多个进程或者线程都可以操作的资源
临界区: 操作临界资源的代码段

同步: 同步是一种合作关系, 为完成某个任务, 多进程或者多线程之间形成一种协调, 按照条件次序执行, 相互传递告知资源情况. 这种协调可能是因为阻塞关系而达成的
互斥: 互斥是一种制约关系, 当一个进程或线程进入到临界区会进行加锁操作, 此时, 其他进程或线程在企图操作临界资源就会阻塞. 只有当资源被释放才能进行操作

---------------------------------------

事件 Evnet

    multiprocessing.Event 类, 是threading.Event的模拟实现

    创建事件对象
    et = multiprocessing.Event()

    提供事件阻塞, 事件被设置等到了返回True, 由超时结束等待返回False
    et.wait([timeout])

    对事件对象进程设置, 此时wait判断如果事件被set则结束阻塞
    et.set()

    清除事件对象的set, wait将会在等待
    et.clear()

    检测对象是否被设置, 被设置返回True, 没有返回False
    et.is_set()

    自我理解: 事件就像一个进程的共享开关, 使用set开, clear关, 当进程中如果有wait, 遇到set的的事件, 会通过, 而没有set的, 将会一直等待.
             如果一个进程需要在另一个进程执行到一定程度时才能继续运行(也许中间需要传点数据什么的), 那可以使用事件来.
             第一个进程执行到一定程度时set事件, 之后另一个进程wait到了执行某个操作

---------------------------------------

锁 Lock

    multiprocessing.Lock 类, 是threading.Lock的模拟实现

    创建Lock对象
    lo = multiprocessing.Lock()
    
    上锁, 默认阻塞
    lo.acquire(block=True, timeout=None) 

    解锁
    lo.release() 

    使用with
    with Lock对象:   # 给with段代码上锁
        ...

    当with代码段结束自动解锁

    * 在Lock对象处于上锁状态的时候, 再企图上锁则会阻塞直到锁被释放, 才能继续执行上锁操作
    * 有锁的方法只会和有相同锁的方法之间实现锁, 相互间才会唯一运行

