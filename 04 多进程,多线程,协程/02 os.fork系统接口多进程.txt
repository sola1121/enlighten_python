
需求, 编写一个程序可以同时做多件事情

方案: 使用两个进程分别完成预定的事件

---------------------------------------

os中的进程控制

进程的创建

os.fork()   # 只能在linux或unix下使用
    功能: 创建一个新的进程
    参数: 无
    返回值: 失败返回一个负数
            成功, 0 在子进程中fork的返回值
                大于0的正整数(新的进程的PID)在父进程中的返回值

说明: 
    父进程中fork之前的内容子进程会同样复制, 但父子进程的空间独立, fork之后的修改不会影响到对方
    父子进程在执行上互不影响, 谁先执行, 谁先执行完不确定
    子进程虽然复制父进程的空间, 但是又自己的特性, 比如自己的PID, 进程PCB, 进程栈空间等

自己的理解:
    运行时, 会创建一个新的进程, 该进程将会拷贝运行时的所有父进程内容来重新执行(在代码上表现为复制所有的代码)
    子进程的pid在子进程中返回为0, 子进程的pid在父进程中返回为大于0的整数进程号
    通过判断语句可以很好的区分父子进程, 然后运行不同的功能
    父子进程是相互独立的, 创建后就不会有有影响了
    父子进程两者的执行先后不一定, 这和他们抢夺资源有关, 可以使用time.sleep延迟子进程执行以控制其先后

通过接口创建进程: 便于控制, 可以在程序运行时随时根据需要创建

进程相关的函数

获取PID号
os.getpid()
    功能: 获取当前进程的PID号
    返回值: 当前进程PID

os.getppid()
    功能: 获取当前进程父进程的PID号
    返回值: 父进程PID


进程的退出

os._exit(status)
    功能: 结束一个进程
    参数: 表示进程的结束状态, 是一个整数
          大于或等于0: 约定上表示正常退出
          负数: 约定上表示非正常退出

sys.exit([status])
    功能: 通过抛出异常, 结束进程
    参数: 传入一个正整数表示结束状态
          传入字符串表示结束打印

---------------------------------------

孤儿进程: 父进程先于子进程退出, 此时子进程变为孤儿进程
    孤儿进程会被系统指定的进程所'收养', 该进程成为孤儿进程新的父进程, 这是为了保证进程树的完整性
    孤儿进程在退出时, 其继父会为其回收资源

僵尸进程: 子进程先于父进程退出, 但是父进程没有处理子进程的退出状况, 子进程就会成为僵尸进程
    僵尸进程会直流PCB的部分信息在内存中, 大量的僵尸进程会消耗系统资源, 所以应该尽量避免僵尸进程的产生

    如何避免僵尸进程的产生
    1) 让父进程先退出 (不好控制), 子进程变为孤儿进程
    2) 让父进程处理子进程的退出
        (1) 使用 os.wait 或者 os.waitpid 函数
            os.wait()
                功能: 等待子进程的退出进行处理, 是一个阻塞函数
                参数: 无
                返回值: 元组, 第一个值为退出的子进程PID, 第二个值为子进程退出状态

            os.waitpid(pid, option)
                功能: 等待子进程的退出
                参数: pid, 值为-1或大于0的整数, -1表示等待任意的子进程退出, 大于0的整数表示等待相应pid的子进程 
                      option, 值为0或WNOHANG, 0表示阻塞等待 , 值为0或WNOHANG表示非阻塞等待
                返回值: 元组, 第一个值为退出的子进程PID, 第二个值为子进程退出状态

                waitpid(-1, 0) 功能可以看做和 wait() 功能一样

        (2) 使用信号处理
            在父进程中, 忽略子进程的发送信号
            signal.signal(signal.SIGCHID, signal.SIG_ING)

    3) 创建二级子进程
        父进程创建子进程后等待子进程退出
        子进程创建二级子进程后马上退出, 二级子进程成为孤儿
        让父进程和二级子进程处理具体事件

        示例: 
            pid_1 = os.fork()
            if pid_1 < 0:
                print("Failed to create first process")
            elif pid_1 == 0:
                pid_2 = os.fork()
                if pid_2 < 0:
                    print("Failed to create second process")
                elif pid_2 == 0:
                    ...do something   # 通过子进程创建的孙子进程
                else:
                    os._exit(0)   # 将子进程退出, 让孙子进程成为孤儿, 这个就是二级子进程
            else:
                os.wait()   # 捕获子进程退出, 回收资源
                ...do something   # 最初的根进程
