协程 Coroutine
    协程或又叫微线程, 纤程, 协程本质是在一个线程内, 通过轮询的方式执行不同的任务.
    对比于进程与线程是系统CPU的能力, 协程是由程序员通过代码实现的, 其建立在系统的线程之上.

工作原理
    通过应用层记录程序的上下文栈区, 实现程序运行中的跳跃. 进而实现选择代码段执行.

协程的资源消耗
    一般一个线程栈大小为1MB, 使用多线程, 在高并发下, cpu大部分的时间都将用于切换线程上下文.
    由于线程的切换是在内核完成的, 会耗费额外的空间和时间. 而且由于内存都分配给线程栈了, 将频繁地进行内存置换算法, 浪费了很多cpu时间片.

    对比协程, 可以理解为一种在线程里跑的子线程, 它的默认栈空间很小 (比如go的协程栈默认大小为2KB). 
    当多个协程在一个线程上运行时, 协程间会切换着运行, 协程的切换完全在用户态完成, 而且时机由程序员来自行调度, 从而使得线程的并发量大大提升.

    但要注意的是协程只适用于IO密集型程序(大部分时间在等待的).
    对于计算密集型程序, 协程的优势并不大, 因为没有给它切换的时间, cpu大部分时间都在工作.
    常见的IO密集型程序有 网络请求、文件读写、数据库查询等，

优点:
    无需多线程切换的开销
    资源消耗非常少
    无需进行同步互斥操作
    对IO操作并发性极好
缺点:
    无法利用计算机多核资源
    如果程序阻塞会阻塞整个程序运行


异步IO
    同步: 先执行第一个事务, 如果遇到阻塞, 则进行等待直到第一个事务执行完毕, 再执行第二个任务.
    异步: 执行第一个事务后, 如果遇到阻塞, 则会执行第二个事务, 不会等待. 可以通过状态, 通知, 回调来调用处理结果.
    

---------------------------------------

Python中协程的发展

    1) python实现协程基本原理 yield语句
        示例
            import time

            def fun_a():
                while True:
                    print(f"{fun_a.__name__}调用")
                    yield
                    time.sleep(1)

            def fun_b(gen):
                while True:
                    print(f"{fun_b.__name__}调用")
                    gen.__next__()   # next(gen)

            # a 为fun_a函数的生成器, 将其给fun_b函数
            # fun_b函数将先执行, 打印fun_b调用, 然后获取生成器中的一个对象, 该对象调用, 将打印fun_a调用
            # 以上, 将会不断的交替执行, 这就是任务的切换
            a = fun_a()
            fun_b(a)


    2) 在最早的Python 3.4中，协程函数是通过 @asyncio.coroutine 和 yeild from 实现的, 如:

        import asyncio
        
        @asyncio.coroutine
        def func1(i):
            print("协程函数{}马上开始执行。".format(i))
            yield from asyncio.sleep(2)
            print("协程函数{}执行完毕!".format(i))
        
        if __name__ == '__main__':
            # 获取事件循环
            loop = asyncio.get_event_loop()
        
            # 执行协程任务, 直到完成
            loop.run_until_complete(func1(1))
        
            # 关闭事件循环
            loop.close()


    2) asyncio / await 语法的引入
    
        Python 3.5以后引入了async/await 语法定义协程函数, 如

        async def func1(i):
            print("协程函数{}马上开始执行。".format(i))
            await asyncio.sleep(2)
            print("协程函数{}执行完毕!".format(i))
        
        通过 async/await 语法来声明 协程 是编写 asyncio 应用的推荐方式。


    3) 更简洁的执行协程对象
        根据协程在Python中的实现, 执行协程任务, 需要三步, 即
            (1) 获取事件循环
            (2) 将协程对象注册到事件循环中执行
            (3) 关闭事件按循环
        Python 3.7提供了一个更简便的asyncio.run方法，以便能够更快速的执行一个协程, 如
            asyncio.fun(func(1))

        执行协程函数只会得到协程对象，不会立刻执行函数内的代码。 如
            <coroutine object func at 0x1053bb7c8>

每个协程函数都以async声明，以区别于普通函数，对于耗时的代码或函数使用await声明，表示碰到等待时挂起，以切换到其它任务。


---------------------------------------

asyncio 标准库

    1) asyncio中的基本概念

        asyncio 的编程模型本质是一个消息循环
            一般先定义一个协程函数(或任务), 从 asyncio 模块中获取事件循环loop.
            然后把需要执行的协程任务(或任务列表)扔到事件loop中执行，就实现了异步IO.

        event_loop事件循环: 程序开启一个无限的循环, 程序员可以将一些函数注册到事件循环上, 当满足事件发生的时候, 调用相应的协程函数.
                           事件循环会对当前存在的任务进行状态的判断
                           如, 已完成, 未完成
                                对已完成的任务会进行删除, 如果未完成的任务/等待执行的任务会被事件循环调度
                           如果当前事件循环中的任务已经全部完成, 则事件循环列表为空, 会中断循环并退出

        coroutine协程: 协程对象, 指一个使用async关键字定义的函数, 该函数的调用不会立即执行函数, 而是会返回一个协程对象.
                      协程对象需要注册到事件循环, 由事件循环调用.

        task任务: 一个协程对象就是一个原生可以挂起的函数, 任务则是对协程进一步的封装, 其中包含任务的各种状态.

        future: 代表将来执行或者没有执行的任务的结果, 他和task没有本质上的区别

        协程: 通过async 关键字装饰的函数是一个协程函数, 调用该函数会返回一个协程对象

        async 关键字: async定义一个协程.
                     格式: async def 函数名(参数): pass

        await 关键字: 获取可等待对象的返回值, 若协程函数有返回值, 只有拿到返回值才会解除阻塞
                     遇到阻塞后，先挂起当前协程（任务），让事件循环去执行其他任务（如果有的话），等待“可等待对象”执行完成后，再继续执行下面的代码。
                    格式: await 可等待对象
                    格式: 变量名 = await 可等待对象
                注意
                    await是用来等待任务返回结果的, 不是用来进行异步任务并发的

        可等待对象
            可等待对象是指可以在await语句中使用的对象，它主要有三种：协程对象、Task对象和 Future对象

    2) 协程对象
        coroutine对象

        以async def 函数名(): pass 的格式定义的函数, 为协程函数, 当执行一个协程函数, 会返回一个协程对象.
    
    3) Task对象
        Task对象用于向事件循环中加入任务.

        Task用于开发调度协程, 通过asyncio.create_task(协程对象)创建(该函数于Python3.7中添加).
        也可以使用asyncio.ensure_future(协程对象)创建一个Task对象.

        asyncio.run_until_complete的参数是一个future对象, 当传入一个协程, 其内部会自动封装成Task.

        在协程嵌套中
            ret1 = await fun1()
            ret2 = await fun2()
        await仅会将fun1提交到事件循环中, fun2的await并未执行

        通过将协程对象变为Task对象, 使await不阻塞
            task1 = asyncio.create_task(fun1())
            task2 = asyncio.create_task(fun2())

            ret1 = await task1
            ret2 = await tssk2
        Task对象不是阻塞的, await将会把这两个Task对象同时提交到任务循环中


    2) 运行协程的三种主要方式
        (1) 用asyncio.run()函数用来运行.
        (2) 使用await关键字"等待"一个协程对象.
        (3) asyncio.create_task()函数用来并发运行作为 asyncio 任务的多个协程。




补充
    inspect 模块来检查函数的类型。特别是，您可以使用 inspect 模块的 isasyncgenfunction() 和 iscoroutinefunction() 函数来检查函数是否是异步生成器函数或协程函数。
